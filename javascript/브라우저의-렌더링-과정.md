# 브라우저의 렌더링 과정

브라우저는 HTML을 받아서 우리가 보는 화면으로 렌더링하기까지 여러 단계를 거칩니다.


## 1. HTML 파싱 -> DOM 트리 생성
<img width="777" alt="image" src="https://github.com/user-attachments/assets/3eacef87-a607-44be-ac2c-82a8d2cf2869" />


1. HTML응답 요청이 오면, 서버는 파일을 읽고 바이트코드로 변환해 전달합니다.
2. 브라우저는 응답받은 바이트 형태의 문서를 인코딩 방식에 따라 문자열로 변환합니다.
3. 문자열로 변환된 문서를 읽어서 문법적 의미를 갖는 코드의 최소 단위인 코튼들로 분해합니다.
4. 각 토큰을 객체로 변환하여 노드를 생성합니다.
5. 요소간의 부자 관계를 반영하여 노드들을 트리 자료구조로 구성합니다. 이것을 DOM이라고 부릅니다.

> 즉, DOM은 HTML문서를 파싱한 결과로 만들어지는 **트리 구조의 문서 모델** 입니다.

### 🔸 script 태그를 만나면?

HTML 파싱 중 `<script>` 태그를 만나면 DOM 생성이 일시 중단되고, 자바스크립트가 실행됩니다.

- `<script>`: HTML 파싱을 **멈추고 즉시 실행**
- `<script defer>`: 파싱은 계속, **DOMContentLoaded 이후 실행**
- `<script async>`: 파싱과 병렬로 다운로드, **다운로드 후 즉시 실행**

## 2. CSS 파싱 -> CSSOM 트리 생성
<img width="634" alt="image" src="https://github.com/user-attachments/assets/2c823652-3a24-4bdd-9e76-25eaaf708dda" />

HTML 파싱 중 `<link>`, `<style>` 같은 CSS 리소스를 만나면 CSS 파싱이 시작됩니다.
- CSS 역시 바이트 → 문자열 → 토큰 → 노드 순으로 처리되며, **CSSOM(CSS Object Model)** 트리가 생성됩니다.
- CSS 파싱이 완료 되면 HTML 파싱이 중단된 지점부터 이어서 진행됩니다.

## 3. DOM + CSSOM -> 렌더 트리 생성
<img width="857" alt="image" src="https://github.com/user-attachments/assets/ef480163-2834-46b4-ae2b-a8ef4c93acb6" />

- 완성된 DOM, CSSOM을 결합해 **렌더 트리(render tree)** 를 만듭니다.
- 렌더 트리는 시각적으로 렌더링할 수 있는 요소만 포함됩니다.
    - `display:none` 같은 CSS에 의해 비표시 되는 노드는 포함하지 않습니다.
    - `head`, `meta`같은 화면에 렌더링되지 않는 노드도 포함하지 않습니다. 

## 4. 레이아웃 (Reflow)

- 렌더 트리를 기반으로 각 요소의 **위치, 크기, 여백** 등을 계산합니다.
- 이 과정을 **레이아웃 계산** 또는 **리플로우**라고 부릅니다.
- 폰트 크기, 부모 요소 변화, 창 크기 변경 등으로 **다시 계산되면 성능 이슈**가 발생할 수 있습니다.
- width, height, margin, padding, border, display, top, bottom, lefe....


## 5. 페인팅 (Repaint)

- 레이아웃 정보를 바탕으로 각 요소의 **색상, 테두리, 그림자, 배경 등 시각적 정보**를 픽셀로 변환합니다.
- 이 과정을 **페인팅**이라고 합니다.
- background, box-shadow, bordr-radius, border-style, color....

## 6. 컴포지팅(compositing)

- 브라우저는 일부 요소를 **별도 레이어로 분리**하여 GPU로 처리합니다.
- 각 레이어는 최종적으로 하나의 화면으로 **합성(composite)** 되어 사용자에게 렌더링됩니다.

## 💡 리플로우 vs 리페인팅
- Reflow: 위치, 크기, 폰트 등 레이아웃 관련 변경
- Repaint: 색상, 배경, 그림자 등 시각적인 속성 변경

### 발생 예시
- 자바스크립트에 의한 노드의 추가 또는 삭제
- 브라우저 창의 리사이징에 의한 뷰포트 크기 변환
- HTML의 요소의 레이아웃에 변경을 발생 시키는 스타일 변경

> 리플로우는 리페인팅을 유발하지만, 리페인팅은 레이아웃에 영향을 주지는 않습니다.

리플로우와 리페인팅을 다시 실행하는 리렌더링 과정을 비용이 많이 드는, 즉 성능에 악영향을 주는 작업입니다. <br/>
가급적 빈번한 리렌더링이 발생하지 않도록 주의가 필요합니다.

### 💡 tranform, opacity
두 속성은 리플로우와 리페인팅을 발생시키지 않는 속성입니다.

## 🗣️ What-ziny-say

브라우저가 화면을 렌더링 할때는 먼저 HTML을 파싱해서 DOM트리를 생성합니다.  <br/>
CSS도 파싱해서 CSSOM트리를 만들고, <br/>
두 트리가 완성되면 합쳐서 렌더 트리를 만듭니다. <br/>
렌터 트리를 기준으로 각 요소의 크기랑 위치를 계산하는 레이아웃 단계를 거치고, <br/>
그걸 바탕으로 색이나 그림자를 칠하는 페인팅 단계로 넘어갑니다. <br/>
최종적으로 하나의 화면으로 합성하는 컴포지팅 단계를 거치면 비로소 사용자에게 화면이 렌더링 되게 됩니다.


브라우저의 렌더링 과정을 반복해서 실행될수 있는데요 <br/>
자바스크립트에 의해서 노드가 추가 또는 삭제 되거나, <br/>
리사이징에 의해 뷰포트 크기가 변하거나, <br/>
HTML요소의 레이아웃에 변경을 발생시키는 스타일이 변경되거나 하면 리플로우 리페인딩이 실행됩니다. <br/>
빈번한 리렌더링은 성능에 악영향을 줄 수 있어 주의할 필요가 있습니다.



