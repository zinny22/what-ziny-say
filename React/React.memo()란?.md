# React.memo()란?

리렌더링 최적화를 위한 고차 컴포넌트로,<br/>
렌더링 결과를 메모이징함으로써 **불필요한 리렌더링을 건너뛰는 기능**을 제공합니다.

<br/>

## ⚙️ React.memo()의 동작 원리

```tsx
export function ZinyComponent({ title }) {
  return (
    <div>
      <div>title: {title}</div>
    </div>
  );
}

export const MemoizedZinyComponent = React.memo(ZinyComponent);
```

React는 부모 컴포넌트가 리렌더링될 때, 자식 컴포넌트도 기본적으로 리렌더링 됩니다.<br/>
하지만 React.memo로 감싼 컴포넌트는<br/>
**이전 Props와 새 Props를 얕게 비교**해서<br/>
변화가 없다면 리렌더링을 생략합니다.

> 메모이징한 결과를 재사용 하기 때문에, 성능상의 이점이 있습니다.

<br/>

## 🔎 Props의 비교

***얕은비교***<br/>
`React.memo`는 기본적으로 **얕은 비교**를 합니다. 
- 원시값은 값 자체를 비교합니다.
- 객체,배열,함수는 참조 주소를 비교 합니다.

즉 같은 값을 가진 객체라도 매번 새로 생성되면 리렌더링 됩니다.
```tsx
<MyComponent config={{ darkMode: true }} /> // 매번 새로 생성된 객체로 간주됨
```

***그럼 깊은 비교는 가능한가?***<br/>
커스텀 함수를 사용해서 구현은 가능합니다.
```tsx
React.memo(Component, (prevProps, nextProps) => {
  return deepEqual(prevProps, nextProps); // lodash.isequal 등 사용 가능
});
```

하지만 깊은 비교는 비용이 크기 때문에<br/>
오히려 **실시간 렌더 상황**에서는 성능 저하를 유발 할 수 있습니다. <br/>
꼭 필요한 경우에만 사용하도록 주의해야 합니다.

<br/>

## 🧠 언제 사용하는게 좋을까?

1. 부모 컴포넌트가 자주 바뀌지만, 자식의 props가 거의 바뀌지 않을때<br/>
   -> 예: 리스트 내의 버튼, 아이콘 컴포넌트
   
2. 복잡한 UI를 렌더링하거나, 렌더링 비용이 높을때<br/>
   -> 예: SVG, 차트, Canvas
   
3. 정적 props를 주입하고, 이벤트 핸들러도 메모이제이션 되어있을때<br/>
   -> 예: props의 참조가 안정적으로 memo의 효과가 보장되기 때문입니다.
   
4. 외부 라이브러리와 통합 시 불필요한 리렌더링을 줄이고 싶을 때<br/>
   -> 예: React Window

<br/>

## ⚠️ 주의해야 할 점

1. 함수나 객체는 참조값이 바뀌면 리렌더링 됩니다.<br/>
   -> 부모 컴포넌트에서 `() => {}` 혹은 `{}`를 직접 넘기면 매번 새로운 참조가 되기 때문에 memo 효과가 없습니다.

2. children이 변경되지 않아도 리렌더링 될 수 있습니다.

3. 불필요한 사용은 오히려 성능의 저하를 불러옵니다.<br/>
   -> `React.memo` 자체도 비교 연산을 진행하기 때문에 가벼운 컴포넌트를 감싸면 오히려 느려질 수 있습니다.

4. state나 context를 직접 사용하는 경우<br/>
   -> props에 무관한 리렌더링이 발생하는 경우는 memo가 막아주지 못합니다.

<br/>


## 🗣️ What-ziny-say

React.memo는 리렌더링을 최적화 하기 위한 고차 컴포넌트 입니다.<br/>
이전의 props와 새 props를 얕은 비교를 통해 비교하고,<br/>
변경이 없다면 메모이징된 결과를 재사용함으로써, **불필요한 리렌더링을 방지**합니다.

props를 비교할때, 원시값은 값 자체를 비교하지만<br/>
그 이외의 값은 **참조 주소를 통해 비교** 하기 때문에<br/>
같은 값을 가진 객체라도 새로 생성되면 리랜더링이 진행됩니다.

부모 컴포넌트가 자주 바뀌는데 비해 자식의 props가 바뀌지 않은 경우나,<br/>
렌더링 비용이 높은 컴포넌트 이거나,<br/>
이벤트 핸들러도 메모이제이션 되어있는 경우에<br/>
React.memo를 사용하는 효과가 있습니다.

state, context의 사용이 많거나,<br/>
너무 가벼운 컴포넌트에 사용을 하면<br/>
오히려 성능 저하의 이슈가 있을 수 있으니 꼭 필요할때만 사용하는 습관이 필요하다고 생각합니다.
