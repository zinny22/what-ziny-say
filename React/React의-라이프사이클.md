# React의 라이프사이클

> “리스트에 항목 하나 추가할때, 컴포넌트는 어떻게 반응할까?”

React를 제대로 이해하기 위해선 컴포넌트가 언제, 어떻게 실행되고 제거되는지인<br/>
**라이프사이클(Lifecycle)**의 흐름을 알아야 합니다.

<br/>

## 1️⃣ mounting - 처음 렌더링 되는 순간

컴포넌트가 최초로 렌더링 되어서 DOM에 생성되는 순간 입니다. 

- useState, useRef, useContext 등을 초기화 합니다.
- useEffect(() => {}, []) → DOM이 생성된 뒤 1회 실행

```jsx
useEffect(() => {
  console.log("🟢 마운트됨");
}, []);
```

<br/>

## 2️⃣ updating (= 리렌더링)

리액트의 리렌더링 조건(state, props, context)에 따른 변화로  <br/>
컴포넌트 함수가 다시 실행되고 UI가 갱신되는 단계입니다.
- useEffect(() => {}, [deps]) → 의존값이 바뀌면 실행됩니다. 의존값이 없는 useEffect는 실행되지 않습니다.
- 단순하게 함수가 실행되는 것은 아니고, Virtual DOM 비교 후 필요한 DOM만 변경하게 됩니다.

```jsx
useEffect(() => {
  console.log("🔁 특정 값이 변경됨", count);
}, [count]);
```
> 리렌더링은 DOM 전체 변경이 아닙니다


<br/>

## 3️⃣ unmounting

컴포넌트가 DOM에서 사라지는 단계입니다.
- useEffect안에 return 함수가 실행됩니다.
- 이벤트 리스너 제거, 타이머 해제에 사용됩니다.
  
```jsx
useEffect(() => {
  console.log("🟢 마운트");

  return () => {
    console.log("❌ 언마운트됨");
  };
}, []);
```

<br/>

## 💡 리스트에 아이템을 추가하면 어떻게 될까?

```jsx
const items = [{ id: 1 }, { id: 2 }];

return (
  <ul>
    {items.map((item) => (
      <Item key={item.id} data={item} />
    ))}
  </ul>
);
```
### 🤔 만약 [3, 1, 2]로 새롭게 바뀐다면?
React에서 리스트는 key를 기준으로 가상 DOM과 비교(diff)를 합니다. <br/>
key가 변경되지 않은 컴포넌트는 재사용하고, 새롭게 생성된 key는 새로 마운트되게 됩니다. 

즉 key가 3번인 컴포넌트만 새로 마운트 되고, <br/>
key가 1,2인 컴포넌트는 재사용된다는 것입니다. 

여기서 알 수 있는 것은 React에서는 key값을 중요하게 생각한다는 것입니다. <br/>

### key값에 index 쓰면 벌어지는 일
새로운 값이 배열 가장 앞에 추가되는 순간, 모든 key 값이 바뀌게 됩니다. 
그럼 React는 모든 컴포넌트를 새로 마운트하게되고,
이것은 성능의 저하나, 예상치 못한 동작을 야기시킵니다.

그래서 배열에서는 `고유한 key값`을 사용하는것이 중요합니다.

## 🗣️ What-ziny-say

리액트 컴포넌트는 마운트, 업데이트(리렌더링), 언마운트 과정을 거칩니다.<br/>
마운트에서는 처음 생성되는 단계를 의미합니다. <br/>
주의해야 할 부분은 업데이트 입니다. 

업데이트 단계에서는 모든 UI를 다시 그리지 않고,<br/>
가상 DOM을 이용해 필요한 부분만 업데이트 하게 됩니다. 

언마운트 과정은 컴포넌트가 DOM에서 사라지는 단계입니다.<br/>
예시로는 이벤트 리스너를 제거하거나, 타이머를 해체 할때 입니다.

리액트에서 리스트 렌더링의 특징은 특히 업데이트 과정을 잘 나타내고 있습니다
key 값에 따라서 컴포넌트를 재 사용할지, 새로 마운트 할지 결정하기 때문에,
항상 고유한 key를 사용해야 합니다.


